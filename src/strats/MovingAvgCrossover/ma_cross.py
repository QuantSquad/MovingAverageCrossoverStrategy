"""
This module implements a Moving Average Crossover (MACO) strategy for quantitative trading.

The Moving Average Crossover strategy is a widely used technical analysis method in trading. It involves 
using two moving averages of a security's price, one short-term and one long-term. A buy signal is generated 
when the short-term average crosses above the long-term average, while a sell signal is triggered when the 
short-term average crosses below the long-term average. This strategy is commonly used to identify the direction 
of a trend and potential reversal points.

Key Components:
- MovingAverageCrossover: A class that encapsulates the logic for calculating moving averages and generating 
  trading signals based on the crossover points.
- MovingAverageCrossPortfolio: A class for backtesting the strategy on historical data. It simulates portfolio performance 
  by executing trades based on the signals generated by the MovingAverageCrossover and tracks the portfolio's 
  value over time.


Usage:
The classes and functions in this module can be imported and used to instantiate a MACO strategy, 
backtest it with historical data, and analyze its performance.

Example:
    from ma_cross import MovingAverageCrossover, BacktestPortfolio

    # Initialize the strategy and backtest
    backtest = MovingAverageCrossPortfolio(instrument='AAPL', start_date="2020-01-01", end_date="2022-01-01")
    portfolio_performance = backtest.portfolio

Note:
This strategy, like all trading strategies, involves risk and may not be suitable for all types of investors. 
It is recommended to thoroughly backtest any strategy using historical data before live trading.
"""

import numpy as np
import pandas as pd
from src.data.data_collection import InstrumentInfo
from src.backtest.strategy import Strategy
from src.backtest.portfolio import Portfolio


class MovingAverageCross(Strategy):
    """
    The MovingAverageCross class is a concrete implementation of the Strategy abstract base class, 
    specializing in generating trading signals based on the Moving Average Crossover strategy.

    This strategy computes signals based on the crossing of a short-term moving average (short_window)
    over a long-term moving average (long_window) of a financial instrument's adjusted closing prices.

    The generated signals are represented in a pandas DataFrame, where:
    - A signal value of 1 indicates a 'buy' action based on the strategy.
    - A signal value of -1 could be interpreted as 'sell' if the positions DataFrame is extended to include negative values.
    - A signal value of 0 indicates a 'hold' or 'neutral' action.

    The class expects the 'instrument_historical_data' DataFrame to have a time-series index and 
    includes columns necessary for computing moving averages (like 'adj_close').

    Attributes:
        instrument (str) : The financial instrument (e.g., stock ticker) for which data is collected
        start_date (str) : The start date for the data collection in 'YYYY-MM-DD' format.
        end_date (str) : The end date for the data collection in 'YYYY-MM-DD' format.
        instrument_historical_data (pd.DataFrame): A DataFrame containing the historical data of the
                                                    financial instrument, including at least an 'adj_close' column.
        short_window (int) : The window size of the short-term moving average. Default is 30 periods.
        long_window (int) : The window size of the long-term moving average. Default is 60 periods.
    Methods:
        generate_signals : Implements the logic for signal generation based on the moving average crossover strategy.
    Usage example:
        >>> MAC = MovingAverageCross("AAPL", "2020-01-01", "2022-01-01")
    """

    def __init__(self, instrument: str, start_date: str, end_date: str, short_window: int = 30,
                 long_window: int = 60) -> None:
        self.instrument = instrument
        self.start_date = start_date
        self.end_date = end_date
        self.instrument_historical_data = InstrumentInfo(
            self.instrument, self.start_date, self.end_date).historical_data
        self.short_window = short_window
        self.long_window = long_window

    def generate_signals(self) -> pd.DataFrame:
        """
        Generates trading signals based on the Moving Average Crossover strategy.

        This method calculates the short-term and long-term moving averages of the instrument's
        adjusted closing prices and generates signals based on the crossover of these moving averages.

        A signal is generated when the short-term moving average crosses above the long-term moving average,
        indicating a potential upward trend (buy signal), and vice versa for a downward trend.

        Note:
            - The method assumes that 'instrument_historical_data' contains a column named 'adj_close' with adjusted closing prices.
            - The 'signal' column does not represent exit (sell) signals explicitly. Implementations may extend this method to include such signals.

        The method returns a DataFrame with the following columns:
            - 'signal': The trading signals, where 1 represents a buy signal (short-term moving average
                        crosses above the long-term moving average) and 0 represents no action.
            - 'short_mavg': The calculated short-term moving average.
            - 'long_mavg': The calculated long-term moving average.
            - 'positions': The difference in signals from the previous period, useful for identifying trade entry and exit points.

        Returns:
            pandas.DataFrame: A DataFrame indexed similarly to 'instrument_historical_data' with columns
                            for 'signal', 'short_mavg', 'long_mavg', and 'positions'.
        Usage:
            >>> print(MovingAverageCross("AAPL", "2020-01-01", "2022-01-01").generate_signals())
        """
        signals = pd.DataFrame(index=self.instrument_historical_data.index)
        signals['signal'] = 0

        signals['short_mavg'] = self.instrument_historical_data['adj_close'].rolling(
            window=self.short_window).mean()
        signals['long_mavg'] = self.instrument_historical_data['adj_close'].rolling(
            window=self.long_window).mean()

        signals.iloc[self.short_window:, signals.columns.get_loc('signal')] = np.where(
            signals['short_mavg'].iloc[self.short_window:] > signals['long_mavg'].iloc[self.short_window:], 1, 0)

        signals['positions'] = signals['signal'].diff()

        return signals


class MovingAverageCrossPortfolio(Portfolio):
    """
    The MovingAverageCrossPortfolio class is a concrete implementation of the Portfolio abstract 
    base class, designed specifically for handling portfolios based on the Moving Average Cross strategy.

    This class takes the historical data of a financial instrument and the signals generated by a 
    Moving Average Cross strategy to create and backtest a portfolio. It handles the allocation of 
    positions based on the strategy's signals and calculates the portfolio's performance over time.

    The generate_positions method interprets the trading signals to allocate positions, which are then used
    by the backtest_portfolio method to simulate portfolio performance, taking into account the positions,
    historical prices, and capital flows.

    Note:
        - The strategy assumes a simple allocation of 100 units of the instrument per 'buy' signal.
        - The backtest_portfolio method calculates an equity curve, cash balance, and returns, 
          providing a simplified view of how the strategy would have performed historically.

    Attributes:
        instrument (str): The identifier (e.g., ticker symbol) of the financial instrument.
        start_date (str) : The start date for the data collection in 'YYYY-MM-DD' format.
        end_date (str) : The end date for the data collection in 'YYYY-MM-DD' format.
        strategy_results (MovingAverageCross) : Results after applying the MACO strat.
        instrument_historical_data (pd.DataFrame): A DataFrame containing the historical data of the instrument.
        instrument_signals (pd.DataFrame): A DataFrame containing the trading signals generated by the strategy.
        initial_capital (float): The initial capital amount for the portfolio. Default is 100,000.0.
        positions (pd.DataFrame): A DataFrame representing the allocated positions in the portfolio over time.
        portfolio (pd.DataFrame): A DataFrame representing the portfolio's performance metrics, such as holdings,
                                  cash, total value, and returns.
    Methods:
        generate_positions: Allocates positions in the portfolio based on the trading signals.
        backtest_strategy: Backtests the strategy, calculating performance metrics like total value and returns.
    Usage:
        >>> MACP = MovingAverageCrossPortfolio("AAPL", "2020-01-01", "2022-01-01")
    """

    def __init__(self, instrument: str, start_date: str, end_date: str, initial_capital: float = 100000.0) -> None:
        self.instrument = instrument
        self.start_date = start_date
        self.end_date = end_date
        self.strategy_results: MovingAverageCross = MovingAverageCross(
            self.instrument, self.start_date, self.end_date)
        self.instrument_historical_data: pd.DataFrame = self.strategy_results.instrument_historical_data
        self.instrument_signals: pd.DataFrame = self.strategy_results.generate_signals()
        self.initial_capital = initial_capital
        self.positions = self.generate_positions()
        self.portfolio = self.backtest_strategy()

    def generate_positions(self) -> pd.DataFrame:
        """
        Generates a DataFrame containing position values for a financial instrument based on signals.

        This method creates a DataFrame with the same index as `self.instrument_signals` and initially fills it with zeros.
        It then sets the column corresponding to `self.instrument` to the values from the `signal` column in 
        `self.instrument_signals`, multiplied by 100. This represents the position values for the specified instrument.

        Note:
            The method assumes that `self.instrument_signals` is a DataFrame with a column named 'signal', 
            and `self.instrument` is the name of the instrument (column name) for which positions are to be generated.

        Returns:
            pd.DataFrame: A DataFrame where each row represents a position value for the specified instrument 
                          at a particular time (as indicated by the index). The position values are scaled by a factor of 100.
        Usage:
            >>> MACP = MovingAverageCrossPortfolio("AAPL", "2020-01-01", "2022-01-01")
            >>> print(MACP.generate_positions())
        """
        positions = pd.DataFrame(
            index=self.instrument_signals.index).fillna(0.0)
        positions[self.instrument] = 100 * self.instrument_signals["signal"]

        return positions

    def backtest_strategy(self) -> pd.DataFrame:
        """
        Conducts a backtest of a portfolio based on historical data and position signals.

        This method simulates a trading strategy by calculating the value of a portfolio over time.
        It takes into account the historical adjusted close prices of the instrument, the positions held, 
        and the cash flows resulting from changes in these positions. The portfolio is evaluated based on 
        the initial capital and the positions in the specified financial instrument.

        The portfolio DataFrame includes the following columns:
        - "Amount of {instrument}": The quantity of the instrument held at each time point.
        - "position_value": The market value of the held position at each time point.
        - "holdings": Identical to "position_value", representing the market value of the position.
        - "cash": The cash component of the portfolio, taking into account the capital and cash flows from trades.
        - "total": The total value of the portfolio (cash + holdings).
        - "returns (%)": The percentage return of the portfolio relative to the initial capital.

        The method assumes the presence of `self.positions` DataFrame with position data for the instrument,
        `self.instrument_historical_data` DataFrame with historical price data (including an "adj_close" column),
        and `self.initial_capital` indicating the initial amount of capital available.

        Returns:
            pd.DataFrame: A DataFrame indexed by time with columns detailing the portfolio's performance over time.
        Usage:
            >>> MACP = MovingAverageCrossPortfolio("AAPL", "2020-01-01", "2022-01-01")
            >>> print(MACP.backtest_strategy())
        """
        portfolio = pd.DataFrame(index=self.instrument_historical_data.index)

        portfolio[f"Amount of {self.instrument}"] = self.positions[self.instrument]
        position_values = self.positions[self.instrument] * \
            self.instrument_historical_data["adj_close"]
        portfolio["position_value"] = position_values
        portfolio["holdings"] = position_values

        pos_diff = self.positions[self.instrument].diff()
        cash_flows = pos_diff * self.instrument_historical_data["adj_close"]
        portfolio["cash"] = self.initial_capital - cash_flows.cumsum()

        portfolio["total"] = portfolio["cash"] + portfolio["holdings"]

        portfolio["returns (%)"] = (
            (portfolio["total"] - self.initial_capital) / self.initial_capital) * 100

        return portfolio
